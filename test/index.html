<!DOCTYPE html>
<html lang="en">
<head>
    <title>Curtain Testing</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="libs/Three.js"></script>
    <script src="libs/Detector.js"></script>
    <script src="build/cannon.js"></script>
    <script src="https://cdn.flashtalking.com/frameworks/js/gsap/1.17.0/plugins/CSSPlugin.min.js"></script>
    <script src="https://cdn.flashtalking.com/frameworks/js/gsap/1.17.0/easing/EasePack.min.js"></script>
    <script src="https://cdn.flashtalking.com/frameworks/js/gsap/1.17.0/TweenLite.min.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
</head>

<body>
<script src="http://cdn.flashtalking.com/frameworks/js/api/2/9/html5API.js"></script>
<div id="wc_cont">
    <div id="close_btn"></div>
    <div id="adSpace">
        <img id="ad_img"/>
    </div>
    <img id="bg_img"/>
</div>

<script>

    //THREE defined
    var dt = 1/60, R = 0.2;
    var clothMass = 1;  // 1 kg in total
    var clothSize = 1; // 1 meter
    var Nx = 12;
    var Ny = 12;
    var mass = clothMass / Nx*Ny;
    var restDistance = clothSize/Nx;
    var renderer;
    var wc_cont, stats, bgImg;
    var camera, scene;
    var clothGeometry;
    var object;
    var particles = [];
    var world;
    var openWidth; // how much screen do you want to show the ad


    //lcool defined
    var WEBCAP_URL = 'WC_3.png';
    var AD_IMG_URL = "adImage.jpg";
    
    var VELOCITY = 0.3; // y-axis force being pushed on the curtain
    var GRAVITY = -7.82; // gravity set in the y axis
    var DURATION = 2.2; // curtain opening in seconds
    var DELAY = 1.5; // time before curtains open upon loading
    var OPEN_PAD = 0.02; //how much padding beside each ad
    
    var animFrame;
    var ready = false;

    /**
     * Loads the webcapture image and ad image and calls the animate() function to begin the
     * curtain effect
     */

    $(document).ready(function() {

        // Web capture background image set
        var WC = document.getElementById("bg_img");
        WC.src = WEBCAP_URL;

        // Wrapper for the ad unit
        var AU = document.getElementById("adSpace");

        // Wrapper for the AU image used in the effect
        var AD_IMG = document.getElementById("ad_img");
        AD_IMG.src = AD_IMG_URL;

        //make sure both the bg_img and ad_img have loaded before checking width and height
        //console.log("1");

        $("#bg_img, #ad_img").load(function() {
            //console.log("2");
            if (ready){
               // console.log("3");
                initCannon();

                init(WC, AU, AD_IMG);

                animate();
            }
            else {
                ready = true; //after the first img has loaded .load will be called again.
            }
        });
    });

    /*
    * Initializes the particles for the webGL render
    * */
    function initCannon(){

        world = new CANNON.World();
        world.broadphase = new CANNON.NaiveBroadphase();
        //amount of resistant effects
        world.gravity.set(0,GRAVITY,0);
        world.solver.iterations = 30;

        // Create cannon particles
        for ( var i = 0, il = Nx+1; i !== il; i++ ) {
            particles.push([]);
            for ( var j = 0, jl = Ny+1; j !== jl; j++ ) {
                var idx = j*(Nx+1) + i;
                //var p = clothFunction(i/(Nx+1), j/(Ny+1));
                //remove corners of curtain
                var clothFunction = plane(restDistance * Nx, restDistance * Ny);
                var p = clothFunction(i/(Nx), j/(Ny+1));
                var particle = new CANNON.Body({
                    mass: j==Ny ? 0 : mass
                });
                particle.addShape(new CANNON.Particle());
                //particle.linearDamping = 0.2;
                particle.linearDamping = 0.2;
                particle.position.set(
                        p.x,
                        p.y-Ny * 0.92 * restDistance, //this is what makes it go down
                        p.z
                );
                particles[i].push(particle);

                world.addBody(particle);

                //set the velocity of the curtain
                particle.velocity.set(VELOCITY,0,0);
            }
        }

        function connect(i1,j1,i2,j2){
            world.addConstraint( new CANNON.DistanceConstraint(particles[i1][j1],particles[i2][j2],restDistance) );
        }
        for(var i=0; i<Nx+1; i++){
            for(var j=0; j<Ny+1; j++){
                if(i<Nx) connect(i,j,i+1,j);
                if(j<Ny) connect(i,j,i,j+1);
            }
        }
    }

    /**
     * Checks users screen has a pixel ratio of >1 (retina)
     * @returns true if it is, false otherwise
     */
    function isRetina(){
        if (window.devicePixelRatio > 1){
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Sets up the DOM with containers and close,
     * splits the webcaptures image,
     * creates the curtain, splits it, and calls the initial
     * render animation to open it.
     */
    function init(WC, AU, AD_IMG) {

        WC.style.display = "block";
        AD_IMG.style.display = "block";

        wc_cont = document.getElementById("wc_cont");
        bgImg = document.getElementById("bg_img");

        document.body.appendChild( wc_cont );
        document.body.appendChild( AU);

        // scene
        scene = new THREE.Scene();

        // camera
        camera = new THREE.Camera();

        if (isRetina()){
            camera.position.set(0.5,0.5,0);
            if (WC.width > window.screen.availWidth){
                WC.width = window.screen.availWidth;
                wc_cont.style.width = WC.width;
            }
        }
        else {
           // console.log("not retina");
            camera.position.set(0.5,-0.5,0);
        }

        scene.add(camera);

        // lights
        var light;
        scene.add( new THREE.AmbientLight( 0x666666 ) );
        light = new THREE.DirectionalLight( 0xffffff, 1.25 );
        var d = 5;
        light.position.set( d, d, d );
        light.castShadow = true;
        //light.shadowCameraVisible = true;
        light.shadowMapWidth = 1024*2;
        light.shadowMapHeight = 1024*2;
        light.shadowCameraLeft = -d;
        light.shadowCameraRight = d;
        light.shadowCameraTop = d;
        light.shadowCameraBottom = -d;
        light.shadowCameraFar = 3*d;
        light.shadowCameraNear = d;
        light.shadowDarkness = 0.5;
        scene.add( light );

        var clothFunction = plane(restDistance * Nx, restDistance * Ny);

        // cloth geometry
        clothGeometry = new THREE.ParametricGeometry( clothFunction, Nx, Ny, true );
        clothGeometry.dynamic = true;
        clothGeometry.computeFaceNormals();

        // offset each render
        function splitCurtain(off) {
            var curtain = THREE.ImageUtils.loadTexture(WEBCAP_URL); // left half of the display
            curtain.wrapS = curtain.wrapT = THREE.RepeatWrapping;
            curtain.anisotropy = 0;
            curtain.offset.x = off;
            var clothMaterial = new THREE.MeshPhongMaterial({
                alphaTest: 0.5,
                ambient: 0x000000,
                color: 0xffffff,
                specular: 0x333333,
                emissive: 0x222222,
                map: curtain,
                side: THREE.DoubleSide,
                transparent: true
            });
            object = new THREE.Mesh(clothGeometry, clothMaterial);
            object.position.set(off, 0, 0);
            object.transparent = true;
            object.castShadow = true;

            return object;
        }

        var leftCurtain = splitCurtain(-0.5); //leftSide
        var rightCurtain = splitCurtain(0.5); //rightSide

        //addCurtains to scene
        scene.add(leftCurtain);
        scene.add(rightCurtain);

        //match up the WC container width
        wc_cont.style.width = WC.width;

        //if the ad is too big. reduce it by 50 percent
        while(AD_IMG.width/WC.width > 0.9){
            AD_IMG.width = AD_IMG.width/1.5;
            //console.log("adimg adjusted: " + AD_IMG.width);
        }

        function addCloseBtn(){
            var closeBtn = document.getElementById("close_btn");
            closeBtn.addEventListener("click", function() {  closeCurtain(closeBtn, AD_IMG, WC, leftCurtain, rightCurtain)} );
            closeBtn.style.display = "block";
            document.body.appendChild( closeBtn );
        }

        addCloseBtn();

        //prepare scene for rendering
        setRenderValues(WC);

        //Add tilt listener
        addTilt();

        //START ANIMATION
        openCurtain(AU,AD_IMG, WC, leftCurtain, rightCurtain);

    }

    function plane(width, height) {
        return function(u, v) {
            var x = (u-0.5) * width;
            var y = (v+0.5) * height;
            var z = 0;
            return new THREE.Vector3(x, y, z);
        };
    }
    function placeAd(AU,WC) {
        AU.style.display = "block";
        AU.style.position = "absolute";
        AU.style.top = 0;
        AU.style.width = WC.width + "px";
        AU.style.height = WC.height + "px";
    }

    function openCurtain(AU,AD_IMG, WC, leftCurtain, rightCurtain) {
        placeAd(AU,WC);

        //fade out the background
        fade(WC, 1,0);

        openWidth = (AD_IMG.width / WC.width) + OPEN_PAD;
        animateCurtain(leftCurtain, 1, 1-openWidth);
        animateCurtain(rightCurtain, 1, 1-openWidth);
    }
    function closeCurtain(closeBtn,AD_IMG, WC, leftCurtain, rightCurtain){

        animateCurtain(leftCurtain, 1-openWidth,1);
        animateCurtain(rightCurtain, 1-openWidth,1);

        closeBtn.style.display = "none";
        //fade the curtains out

        setTimeout(function (){
            WC.style.display = "block";
            AD_IMG.style.display = "none";
            fade(WC, 0,1);
            cancelAnimationFrame( animFrame );
        }, (DURATION + DELAY)*1000);

        // turn off
        // wait one second and the call myFT.contract() here...
    }
    function animateCurtain(curtain, from, to) {

        setTimeout(function (){
            TweenLite.fromTo(curtain.scale, DURATION, {x: from}, {x: to, ease: Sine.easeOut});
        }, DELAY*1000);
    }
    

    ////RENDERING

    //function onWindowResize() {
       // if(renderer.domElement.width != window.innerWidth){
           // camera.aspect = window.innerWidth / renderer.domElement.height;
            //camera.updateProjectionMatrix();
          //  renderer.setSize( window.innerWidth, renderer.domElement.height );
       // }
   // }

    function animate() {
        world.step(dt);
        animFrame = requestAnimationFrame(animate);
        render();
    }

    function setRenderValues(WC){
        renderer = new THREE.WebGLRenderer( {alpha:true} );
        renderer.setSize(WC.width*2, WC.height*2);
        if (isRetina()){
            renderer.setSize(WC.width*window.devicePixelRatio, WC.height*window.devicePixelRatio);
            renderer.setViewport(0,0, WC.width*window.devicePixelRatio, WC.height*window.devicePixelRatio);
            //console.log(window.devicePixelRatio);
        }
        renderer.setClearColor( 0x000000, 0 ); // the default
        wc_cont.appendChild( renderer.domElement );
        renderer.gammaInput = true;
        renderer.gammaOutput = true;
        renderer.physicallyBasedShading = true;
        renderer.shadowMapEnabled = true;
        //window.addEventListener( 'resize', onWindowResize, false );
    }

    function render() {
        //for particles going down
        for (var i = 0, il = Nx + 1; i !== il; i++) {
            for (var j = 0, jl = Ny + 1; j !== jl; j++) {
                var idx = j * (Nx + 1) + i;
                clothGeometry.vertices[idx].copy(particles[i][j].position);
            }
        }

        //set camera to always look in center of curtain

        clothGeometry.computeFaceNormals();
        clothGeometry.computeVertexNormals();

        clothGeometry.normalsNeedUpdate = true;
        clothGeometry.verticesNeedUpdate = true;


        renderer.render(scene, camera);

    }

    function fade(content, from, to){
        TweenLite.fromTo(content, DURATION, {opacity:from}, {opacity:to});
    }


    ////////////////////////////
    //  Flashtalking API
    var expndedOnce = false;
    var unexpanded = myFT.$("#unexpanded");
    var adspace = myFT.$("#adspace");
    var expanded = myFT.$("#expanded");
    var close = myFT.$("#close_btn");
    var expand = function(){
        unexpanded.css("display", "none");
        expanded.css("display", "block");
        if(expndedOnce == false){
            expndedOnce = true;
            init();
        } else {
            resetAll();
        }
        myFT.expand();
    };
    var contract = function(e){
        expanded.css("display", "none");
        unexpanded.css("display", "block");
        expanded.css("opacity", 1);
        myFT.contract();
    };

    myFT.applyButton(unexpanded, expand);
    myFT.applyClickTag(adspace);

    //debugging
    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    //// ---- UNUSED ----- ////

    /*
     Implements gravity to the curtain for mobile devices with accelerometers. When the
     tilts the device the curtain should remain facing directly perpendicular to they ground
     */

    function addTilt(){
        if (window.DeviceOrientationEvent) {
            window.addEventListener("deviceorientation", function () {
                tilt([event.alpha, event.beta, event.gamma]);
            }, true);
        } else if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', function () {
                tilt([event.acceleration.x * 2, event.acceleration.y * 2]);
            }, true);
        } else {
            window.addEventListener("MozOrientation", function () {
                tilt([orientation.x * 50, orientation.y * 50]);
            }, true);
        }

        function tilt(value){
            TILTX = value[2];
            //TILTX = (-1/Math.sin(x[0]))*GRAVITY;
            console.log("GRAVITY: " + TILTX);
            world.gravity.set(TILTX/15,GRAVITY,0);
            //renderer.render(scene, camera);
        }
    }

</script>
</body>
</html>
